// uic 3.03.2010
//
// модуль для ведения одного или нескольких логов

#pragma once

////////////////////////////////////////////////////////////////////////////////
// типы
////////////////////////////////////////////////////////////////////////////////
typedef int LOGGER_Id;

enum LOGGER_Type
{
	LOGGER_none = 0,
	LOGGER_file = 1,
	LOGGER_view = 2,
	LOGGER_both = 3
};

struct LOGGER_MessageInfo
{
	DWORD m_type;
	CString m_text;
};

struct LOGGER_Messages
{
	LOGGER_Messages();
	~LOGGER_Messages();
	void Setup(int size);
	void Add(LOGGER_MessageInfo* mi);
	LOGGER_MessageInfo* Get(int num);
	int GetMaxNumOfMessages() { return m_size; }
	int GetNumOfMessages() { return m_filled; }
	int GetTotalNumOfMessagesAdded() { return m_total_messages_added; }
protected:
	LOGGER_MessageInfo* m_buffer;
	int m_filled, m_size, m_start_offset, m_total_messages_added;
};

////////////////////////////////////////////////////////////////////////////////
// процедуры
////////////////////////////////////////////////////////////////////////////////

LOGGER_Id LOGGER_InitLog(CString filepath, int num_strings_to_show = 0, int num_strings_to_flush = 1, CWnd* wnd_for_msg = NULL, UINT msg = 0);
////////////////////////////////////////////////////////////////////////////////
// создаёт новый лог для записи в файл и/или ваывода на экран
////////////////////////////////////////////////////////////////////////////////
// filepath				: путь к файлу. может быть NULL, тогда лог без файла
// num_strings_to_show	: для отображаемых логов. сколько строк лога хранить в памяти для показа
// num_strings_to_flush : для файловых логов. раз в сколько строк в файле делать flush
// wnd_for_msg			: для отображаемых логов. окно, которому пошлётся msg о добавлении видимого сообщения
// msg					: для отображаемых логов. msg о добавлении видимого сообщения
////////////////////////////////////////////////////////////////////////////////
// RETURN VALUE			: возвращает идентификатор логгера, который используется дальше для настроек и собственно ведния лога
//						  если -1, то ошибка
////////////////////////////////////////////////////////////////////////////////

bool LOGGER_ShutDownLog(LOGGER_Id id);
////////////////////////////////////////////////////////////////////////////////
// закрывает лог и удаляет объект, соответствующий id
////////////////////////////////////////////////////////////////////////////////
// id					: идентификатор лога
////////////////////////////////////////////////////////////////////////////////
// RETURN VALUE			: при ошибке выдает false. ошибка может быть, если нет такого лога
////////////////////////////////////////////////////////////////////////////////

bool LOGGER_SetupMessageType(LOGGER_Id id, DWORD message_type, CString prefix, LOGGER_Type log_type);
////////////////////////////////////////////////////////////////////////////////
// добавляет/настраивает тип сообщения для лога
////////////////////////////////////////////////////////////////////////////////
// id					: идентификатор лога
// message_type			: идентификатор типа сообщения
// prefix				: префикс, прилепляемый перед сообщениями такого типа
// log_type				: тип лога, для которого разрешен этот тип сообщения
////////////////////////////////////////////////////////////////////////////////
// RETURN VALUE			: при ошибке выдает false. ошибка может быть, если нет такого лога
////////////////////////////////////////////////////////////////////////////////

bool LOGGER_EnableMessageType(LOGGER_Id id, DWORD message_type, LOGGER_Type log_type);
////////////////////////////////////////////////////////////////////////////////
// разрешает/запрещает вывод определённого типа сообщения
////////////////////////////////////////////////////////////////////////////////
// id					: идентификатор лога
// message_type			: идентификатор типа сообщения
// log_type				: тип лога, для которого разрешен этот тип сообщения
////////////////////////////////////////////////////////////////////////////////
// RETURN VALUE			: при ошибке выдает false. ошибка может быть, если нет такого лога,
//						  если нет такого типа сообщения.
//						  если файла нет, а пытаются его разрешить
////////////////////////////////////////////////////////////////////////////////

bool LOGGER_GetMessageTypeEnabled(LOGGER_Id id, DWORD message_type, LOGGER_Type &log_type);
////////////////////////////////////////////////////////////////////////////////
// возарвщает разрешения определённого типа сообщения
////////////////////////////////////////////////////////////////////////////////
// id					: идентификатор лога
// message_type			: идентификатор типа сообщения
// log_type				: результат - тип лога, для которого разрешен этот тип сообщения
////////////////////////////////////////////////////////////////////////////////
// RETURN VALUE			: при ошибке выдает false. ошибка может быть, если нет такого лога,
//						  если нет такого типа сообщения.
////////////////////////////////////////////////////////////////////////////////

bool LOGGER_AddMessage(LOGGER_Id id, DWORD message_type, CString message, bool add_time = false, bool add_date = false);
////////////////////////////////////////////////////////////////////////////////
// пытается добавить сообщение в лог
////////////////////////////////////////////////////////////////////////////////
// id					: идентификатор лога
// message_type			: идентификатор типа сообщения
// message				: текст сообщения
// add_time				: добавлять ли время в начало сообщения
// add_date				: добавлять ли дату в начало сообщения
////////////////////////////////////////////////////////////////////////////////
// RETURN VALUE			: при ошибке выдает false. ошибка может быть, если нет такого лога, если нет такого типа сообщения
////////////////////////////////////////////////////////////////////////////////

void LOGGER_LockAll();
void LOGGER_UnlockAll();
LOGGER_Messages* LOGGER_Lock(LOGGER_Id id);
bool LOGGER_Unlock(LOGGER_Id id);

////////////////////////////////////////////////////////////////////////////////
// end